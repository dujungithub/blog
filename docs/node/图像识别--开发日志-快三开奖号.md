技术点

1  Tesseract.js  识别长串期号

2  OCRAD.js  识别单个开奖号

3  file文件技术

4  canvas  裁切图片 canvas.getContext('2d').drawImage(img,0,0,w,h,0,0,imgW,imgH);

5  canvas  图片信息 canvas.toDataURL  得到图片src信息

6  canvas  像素点rgba值   imgData = canvas.getContext('2d').getImageDate(0,0,1,1);

	   rgba(imgData.data[0],imgData.data[1],imgData.data[2],imgData.data[3]);

7  canvas  灰度化处理  getImageData   处理  context.putImageData(imgData, 0, 0);

		浮点算法  整数算法  移位算法  平均值算法   仅取绿色
	
		    var imgData = context.getImageData(0, 0, imgArea.width, imgArea.height);
		    for (var i = 0; i < imgData.data.length; i += 4) {
		        var R = imgData.data[i]; //R(0-255)
		        var G = imgData.data[i + 1]; //G(0-255)
		        var B = imgData.data[i + 2]; //G(0-255)
		        var Alpha = imgData.data[i + 3]; //Alpha(0-255)
		        //浮点算法
		        var gray = R * 0.299 + G * 0.587 + B * 0.114;
			//整数算法
	    		//var gray = (R*299 + G*587 + B*114 + 500) / 1000;　
	   			//移位算法
	    		//var gray =(R*76+G*151+B*28)>>8;
	    		//平均值算法
	    		//var gray = (R+G+B)/3;
	    		//仅取绿色
	    		//var gray=G;
		        imgData.data[i] = gray;
		        imgData.data[i + 1] = gray;
		        imgData.data[i + 2] = gray;
		        imgData.data[i + 3] = Alpha;
		    }
		    context.putImageData(imgData, 0, 0);

8  canvas  二值化处理  getImageData   处理  context.putImageData(imgData, 0, 0);

	    imgData = context.getImageData(0, 0, imgArea.width, imgArea.height);
	        var index = 255/2;//阈值
	        for (var i = 0; i < imgData.data.length; i += 4) {
	            var R = imgData.data[i]; //R(0-255)
	            var G = imgData.data[i + 1]; //G(0-255)
	            var B = imgData.data[i + 2]; //B(0-255)
	            var Alpha = imgData.data[i + 3]; //Alpha(0-255)
	            var sum = (R + G + B) / 3;
	            if (sum > index) {
	                imgData.data[i] = 255;
	                imgData.data[i + 1] = 255;
	                imgData.data[i + 2] = 255;
	                imgData.data[i + 3] = Alpha;
	            } else {
	                imgData.data[i] = 0;
	                imgData.data[i + 1] = 0;
	                imgData.data[i + 2] = 0;
	                imgData.data[i + 3] = Alpha;
	            }
	        }
	        context.putImageData(imgData, 0, 0);

9  过滤 得到重复最多的值，及重复总和
		function filterNum(arr){
		    var maxCount = 0,
		        maxItem = '',
		        obj = {}
		    arr.forEach(function(item){
		    	if(item != "" && !/[a-z]/i.test(item) && !/[-]/i.test(item)){
		    		obj[item] ? (obj[item].count += 1) : obj[item] = {count: 1}
		        	obj[item].count > maxCount && (maxCount = obj[item].count, maxItem = item)
		    	}
		        
		    })
		    return {item:maxItem,count:maxCount}
		}

10 接近值-乱码正则替换 item = item.replace(/[lLiIT]/i,"1");   和数字1相同的，替换为1，和大S小s替换为5

11 非空 非字母 非-     item != "" && !/[a-z]/i.test(item) && !/[-]/i.test(item))   正则表达式

12 资源文件循环读取，需有序，采用bat方式进行批处理重命名
	rename.bat

	@echo off
	setlocal enabledelayedexpansion
	set count=0
	for /f %%i in ('dir /b *.jpg') do (
			set /a count+=1
			echo 改名：%%i !count!
			rename %%i !count!.jpg
	)



100  输出结果展示

0: (4) [11190126100, 4, 5, 6]
1: (4) [11190126101, 3, 3, 5]
2: (4) [11190126102, 2, 5, 5]
3: (4) [11190126103, 2, 3, 5]
4: (4) [11190126104, 1, 3, 5]
5: (4) [11190126105, 1, 3, 4]
6: (4) [11190126106, 2, 3, 5]
7: (4) [11190126107, 2, 3, 6]
8: (4) [11190126108, 2, 6, 6]
9: (4) [11190126109, 1, 3, 6]
10: (4) [11190126110, 1, 3, 6]
11: (4) [11190126111, 1, 1, 5]
12: (4) [11190126112, 1, 5, 6]
13: (4) [11190126113, 3, 5, 5]
14: (4) [11190126114, 1, 3, 4]
15: (4) [11190126117, 2, 4, 6]
16: (4) [11190126118, 3, 6, 6]
17: (4) [11190126119, 2, 2, 6]
18: (4) [11190126120, 2, 4, 6]
19: (4) [11190126121, 1, 2, 6]
20: (4) [11190126122, 1, 1, 2]
21: (4) [11190126123, 1, 6, 6]
22: (4) [11190126124, 2, 3, 3]
23: (4) [11190126125, 3, 5, 5]
24: (4) [11190126126, 1, 1, 2]
25: (4) [11190126127, 1, 4, 6]
26: (4) [11190126128, 1, 5, 6]
27: (4) [11190126129, 3, 4, 6]






