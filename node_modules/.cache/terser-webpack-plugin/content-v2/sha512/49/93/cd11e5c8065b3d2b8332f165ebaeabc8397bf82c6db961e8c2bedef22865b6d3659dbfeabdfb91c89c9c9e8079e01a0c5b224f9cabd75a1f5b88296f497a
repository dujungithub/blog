{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{372:function(e,t,a){e.exports=a.p+\"assets/img/data.5de7af21.png\"},450:function(e,t,a){\"use strict\";a.r(t);var r=a(43),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"vue响应式原理之官方解释\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue响应式原理之官方解释\"}},[e._v(\"#\")]),e._v(\" Vue响应式原理之官方解释\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[r(\"strong\",[e._v(\"Vue 最独特的特性之一，是其非侵入性的响应式系统\")]),r(\"a\",{attrs:{href:\"https://cn.vuejs.org/v2/guide/reactivity.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://cn.vuejs.org/v2/guide/reactivity.html\"),r(\"OutboundLink\")],1)])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"非官方解释参考：\"),r(\"a\",{attrs:{href:\"https://blog.csdn.net/z1012890225/article/details/88840520\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://blog.csdn.net/z1012890225/article/details/88840520\"),r(\"OutboundLink\")],1)])])]),e._v(\" \"),r(\"p\",[e._v(\"当你把一个普通的 JavaScript 对象传入 Vue 实例作为 \"),r(\"code\",[e._v(\"data\")]),e._v(\" 选项，Vue 将遍历此对象所有的 property，并使用 \"),r(\"a\",{attrs:{href:\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\",target:\"_blank\",rel:\"noopener noreferrer\"}},[r(\"code\",[e._v(\"Object.defineProperty\")]),r(\"OutboundLink\")],1),e._v(\" 把这些 property 全部转为 \"),r(\"a\",{attrs:{href:\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"getter/setter\"),r(\"OutboundLink\")],1),e._v(\"。\"),r(\"code\",[e._v(\"Object.defineProperty\")]),e._v(\" 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。\")]),e._v(\" \"),r(\"p\",[e._v(\"这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 \"),r(\"a\",{attrs:{href:\"https://github.com/vuejs/vue-devtools\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"vue-devtools\"),r(\"OutboundLink\")],1),e._v(\" 来获取对检查数据更加友好的用户界面。\")]),e._v(\" \"),r(\"p\",[e._v(\"每个组件实例都对应一个 \"),r(\"strong\",[e._v(\"watcher\")]),e._v(\" 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:a(372),alt:\"data\"}})]),e._v(\" \"),r(\"h2\",{attrs:{id:\"检测变化的注意事项\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#检测变化的注意事项\"}},[e._v(\"#\")]),e._v(\" \"),r(\"a\",{attrs:{href:\"https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"检测变化的注意事项\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"p\",[e._v(\"由于 JavaScript 的限制，Vue \"),r(\"strong\",[e._v(\"不能检测\")]),e._v(\"数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"对于对象\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对于对象\"}},[e._v(\"#\")]),e._v(\" \"),r(\"a\",{attrs:{href:\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"对于对象\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"p\",[e._v(\"Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 \"),r(\"code\",[e._v(\"data\")]),e._v(\" 对象上存在才能让 Vue 将它转换为响应式的。例如：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"var vm = new Vue({\\n  data:{\\n    a:1\\n  }\\n})\\n\\n// `vm.a` 是响应式的\\n\\nvm.b = 2\\n// `vm.b` 是非响应式的\\n\")])])]),r(\"p\",[e._v(\"对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 \"),r(\"code\",[e._v(\"Vue.set(object, propertyName, value)\")]),e._v(\" 方法向嵌套对象添加响应式 property。例如，对于：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"Vue.set(vm.someObject, 'b', 2)\\n\")])])]),r(\"p\",[e._v(\"您还可以使用 \"),r(\"code\",[e._v(\"vm.$set\")]),e._v(\" 实例方法，这也是全局 \"),r(\"code\",[e._v(\"Vue.set\")]),e._v(\" 方法的别名：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"this.$set(this.someObject,'b',2)\\n\")])])]),r(\"p\",[e._v(\"有时你可能需要为已有对象赋值多个新 property，比如使用 \"),r(\"code\",[e._v(\"Object.assign()\")]),e._v(\" 或 \"),r(\"code\",[e._v(\"_.extend()\")]),e._v(\"。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\\n\")])])]),r(\"h3\",{attrs:{id:\"对于数组\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对于数组\"}},[e._v(\"#\")]),e._v(\" \"),r(\"a\",{attrs:{href:\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"对于数组\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"p\",[e._v(\"Vue 不能检测以下数组的变动：\")]),e._v(\" \"),r(\"ol\",[r(\"li\",[e._v(\"当你利用索引直接设置一个数组项时，例如：\"),r(\"code\",[e._v(\"vm.items[indexOfItem] = newValue\")])]),e._v(\" \"),r(\"li\",[e._v(\"当你修改数组的长度时，例如：\"),r(\"code\",[e._v(\"vm.items.length = newLength\")])])]),e._v(\" \"),r(\"p\",[e._v(\"举个例子：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"var vm = new Vue({\\n  data: {\\n    items: ['a', 'b', 'c']\\n  }\\n})\\nvm.items[1] = 'x' // 不是响应性的\\nvm.items.length = 2 // 不是响应性的\\n\")])])]),r(\"p\",[e._v(\"为了解决第一类问题，以下两种方式都可以实现和 \"),r(\"code\",[e._v(\"vm.items[indexOfItem] = newValue\")]),e._v(\" 相同的效果，同时也将在响应式系统内触发状态更新：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"// Vue.set\\nVue.set(vm.items, indexOfItem, newValue)\\n// Array.prototype.splice\\nvm.items.splice(indexOfItem, 1, newValue)\\n\")])])]),r(\"p\",[e._v(\"你也可以使用 \"),r(\"a\",{attrs:{href:\"https://cn.vuejs.org/v2/api/#vm-set\",target:\"_blank\",rel:\"noopener noreferrer\"}},[r(\"code\",[e._v(\"vm.$set\")]),r(\"OutboundLink\")],1),e._v(\" 实例方法，该方法是全局方法 \"),r(\"code\",[e._v(\"Vue.set\")]),e._v(\" 的一个别名：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"vm.$set(vm.items, indexOfItem, newValue)\\n\")])])]),r(\"p\",[e._v(\"为了解决第二类问题，你可以使用 \"),r(\"code\",[e._v(\"splice\")]),e._v(\"：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"vm.items.splice(newLength)\\n\")])])]),r(\"h2\",{attrs:{id:\"声明响应式-property\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#声明响应式-property\"}},[e._v(\"#\")]),e._v(\" \"),r(\"a\",{attrs:{href:\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%A3%B0%E6%98%8E%E5%93%8D%E5%BA%94%E5%BC%8F-property\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"声明响应式 property\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"p\",[e._v(\"由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"var vm = new Vue({\\n  data: {\\n    // 声明 message 为一个空值字符串\\n    message: ''\\n  },\\n  template: '<div>{{ message }}</div>'\\n})\\n// 之后设置 `message`\\nvm.message = 'Hello!'\\n\")])])]),r(\"p\",[e._v(\"如果你未在 \"),r(\"code\",[e._v(\"data\")]),e._v(\" 选项中声明 \"),r(\"code\",[e._v(\"message\")]),e._v(\"，Vue 将警告你渲染函数正在试图访问不存在的 property。\")]),e._v(\" \"),r(\"p\",[e._v(\"这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例能更好地配合类型检查系统工作。但与此同时在代码可维护性方面也有一点重要的考虑：\"),r(\"code\",[e._v(\"data\")]),e._v(\" 对象就像组件状态的结构 (schema)。提前声明所有的响应式 property，可以让组件代码在未来修改或给其他开发人员阅读时更易于理解。\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"异步更新队列\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#异步更新队列\"}},[e._v(\"#\")]),e._v(\" \"),r(\"a\",{attrs:{href:\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"异步更新队列\"),r(\"OutboundLink\")],1)]),e._v(\" \"),r(\"p\",[e._v(\"可能你还没有注意到，Vue 在更新 DOM 时是\"),r(\"strong\",[e._v(\"异步\")]),e._v(\"执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 \"),r(\"code\",[e._v(\"Promise.then\")]),e._v(\"、\"),r(\"code\",[e._v(\"MutationObserver\")]),e._v(\" 和 \"),r(\"code\",[e._v(\"setImmediate\")]),e._v(\"，如果执行环境不支持，则会采用 \"),r(\"code\",[e._v(\"setTimeout(fn, 0)\")]),e._v(\" 代替。\")]),e._v(\" \"),r(\"p\",[e._v(\"例如，当你设置 \"),r(\"code\",[e._v(\"vm.someData = 'new value'\")]),e._v(\"，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 \"),r(\"code\",[e._v(\"Vue.nextTick(callback)\")]),e._v(\"。这样回调函数将在 DOM 更新完成后被调用。例如：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"<div id=\\\"example\\\">{{message}}</div>\\nvar vm = new Vue({\\n  el: '#example',\\n  data: {\\n    message: '123'\\n  }\\n})\\nvm.message = 'new message' // 更改数据\\nvm.$el.textContent === 'new message' // false\\nVue.nextTick(function () {\\n  vm.$el.textContent === 'new message' // true\\n})\\n\")])])]),r(\"p\",[e._v(\"在组件内使用 \"),r(\"code\",[e._v(\"vm.$nextTick()\")]),e._v(\" 实例方法特别方便，因为它不需要全局 \"),r(\"code\",[e._v(\"Vue\")]),e._v(\"，并且回调函数中的 \"),r(\"code\",[e._v(\"this\")]),e._v(\" 将自动绑定到当前的 Vue 实例上：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"Vue.component('example', {\\n  template: '<span>{{ message }}</span>',\\n  data: function () {\\n    return {\\n      message: '未更新'\\n    }\\n  },\\n  methods: {\\n    updateMessage: function () {\\n      this.message = '已更新'\\n      console.log(this.$el.textContent) // => '未更新'\\n      this.$nextTick(function () {\\n        console.log(this.$el.textContent) // => '已更新'\\n      })\\n    }\\n  }\\n})\\n\")])])]),r(\"p\",[e._v(\"因为 \"),r(\"code\",[e._v(\"$nextTick()\")]),e._v(\" 返回一个 \"),r(\"code\",[e._v(\"Promise\")]),e._v(\" 对象，所以你可以使用新的 \"),r(\"a\",{attrs:{href:\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"ES2017 async/await\"),r(\"OutboundLink\")],1),e._v(\" 语法完成相同的事情：\")]),e._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[e._v(\"methods: {\\n  updateMessage: async function () {\\n    this.message = '已更新'\\n    console.log(this.$el.textContent) // => '未更新'\\n    await this.$nextTick()\\n    console.log(this.$el.textContent) // => '已更新'\\n  }\\n}\\n\")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}